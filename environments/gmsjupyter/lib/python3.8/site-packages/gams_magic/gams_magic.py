#
# GAMS - General Algebraic Modeling System Python API
#
# Copyright (c) 2017-2021 GAMS Development Corp. <support@gams.com>
# Copyright (c) 2017-2021 GAMS Software GmbH <support@gams.com>
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
#

from IPython.core.magic import (Magics, magics_class, line_magic, cell_magic, line_cell_magic)
from IPython.core.magic_arguments import (argument, magic_arguments, parse_argstring)
from gams import *
import gams.database 
import sys
import os
import glob
import numpy
import pandas
from idxcc import *
from gdxcc import *
import gams2numpy

@magics_class
class GamsMagic(Magics):

    def __init__(self, shell):
        # You must call the parent constructor
        super(GamsMagic, self).__init__(shell)

        self.gams_reset()
        
    def getJobName(self):
        self._jobNumber = self._jobNumber + 1
        return "gamsJupyter" + str(self._jobNumber)
    
    @line_magic
    def gams_reset(self, line=""):
        self._jobNumber = 0
        self.ws = GamsWorkspace(working_directory=".")
        self.g2np = gams2numpy.Gams2Numpy(self.ws.system_directory)
        jobName = self.getJobName() + "_reset"
        self.job = self.ws.add_job_from_string("$onMultiR\n", job_name=jobName)
        self.cp = self.ws.add_checkpoint()
        with open(jobName + ".log", "w") as logFile:
            self.job.run(checkpoint=self.cp, output=logFile)
        self.needReset = False
    
    def gams_pull_idx(self, args):
        jobName = self.getJobName() + "_pull_idx"
        gdxFile = os.path.join(self.ws.working_directory, jobName + ".gdx")
        code = "execute_unloadidx \"" + gdxFile + "\" " + " ".join(args.symbols)
        self.job = self.ws.add_job_from_string(code, checkpoint=self.cp, job_name=jobName)
        self.job.run()
        
        idxHandle = new_idxHandle_tp()
        rc =  idxCreateD(idxHandle, self.ws.system_directory, GMS_SSSIZE)
        if not rc[0]:
            raise Exception("Could not create IDX object: " + rc[1])
        status = idxOpenRead(idxHandle, gdxFile)
        if not status:
            raise_idx_exception(idxHandle, "idxOpenRead")
        
        status = idxSetIndexBase(idxHandle, 0)
        if not status:
            idxerror("idxSetIndexBase")
        
        myeps = float.fromhex('0x1.0000000000000p-1022')
        for sym in args.symbols:
            ret, dim, shape, nrRecs, errMsg = idxDataReadStart(idxHandle, sym, GMS_SSSIZE)
            if not ret:
                idxerror("idxDataReadStart")
            shape = shape[:dim]
            arr = numpy.zeros(shape)
            keys = intArray(dim)
            
            for i in range(nrRecs):
                ret, keys, val, chIdx = idxDataRead(idxHandle)
                if not ret:
                    idxerror("idxDataRead")
                else:
                    if val == myeps:
                        if args.epsaszero:
                            val = 0
                        else:
                            val = gams.database.SV_EPS
                    arr.itemset(tuple(keys[:dim]), val)
            self.shell.user_ns[sym] = arr
            status = idxDataReadDone(idxHandle)
            if not status:
                raise_idx_exception("idxDataReadDone")
        status = idxClose(idxHandle);
        if status:
            raise_idx_exception("idxClose")
        idxFree(idxHandle)
        
    def getLatestFile(self, pattern):
        return max(glob.glob(pattern), key=os.path.getmtime)

    @line_magic
    def gams_log(self, line):
        if self.needReset:
            self.gams_reset()
        latestLogFile = self.getLatestFile("gamsJupyter*.log")
        with open(latestLogFile) as f:
            print(f.read())
        
    @magic_arguments()
    @argument(
        '-e', '--execution', action='store_true'
    )
    @line_magic
    def gams_lst(self, line):
        if self.needReset:
            self.gams_reset()
        latestLstFile = self.getLatestFile('gamsJupyter*.lst')
        args = parse_argstring(self.gams_lst, line)
        if args.execution:
            with open(latestLstFile) as f:
                content = f.readlines()
                inExecution = False
                for l in content:
                    if l.startswith("E x e c u t i o n"):
                        inExecution = True
                    elif l.startswith("EXECUTION TIME"):
                        inExecution = False
                    if inExecution:
                        print(l, end="")
        else:
            with open(latestLstFile) as f:
                print(f.read())
        
    @magic_arguments()
    @argument(
        '-k', '--keep', action='store_true'
    )
    @line_magic
    def gams_cleanup(self, line):
        args = parse_argstring(self.gams_cleanup, line)
        
        toBeDeleted = glob.glob('_gams_py_gcp*.g00') + glob.glob('_gams_py_gdb*.gdx') + glob.glob('gamsJupyter*.gms') + glob.glob('gamsJupyter*.gdx') + glob.glob('gamsJupyter*.lst') + glob.glob('gamsJupyter*.log') + glob.glob('gamsJupyter*.pf') + glob.glob('gamsJupyter*.trc')
        
        if args.keep:
            toBeDeleted = set(toBeDeleted) - set([self.getLatestFile(f) for f in ['_gams_py_gcp*.g00', '_gams_py_gdb*.gdx', 'gamsJupyter*.lst', 'gamsJupyter*.log']])
        else:
            self.needReset = True
            try:
                del self.job
                del self.ws
                del self.cp
            except:
                pass

        for f in toBeDeleted:
            try:
                os.remove(f)
            except Exception as e:
                print("Warning:", e)

    @magic_arguments()
    @argument(
        '-d', '--dataframe', action='store_true'
    )
    @argument(
        'symbols',
        nargs='*'
    )
    @argument(
        '-n', '--numpy', action='store_true'
    )
    @argument(
        '-e', '--epsaszero', action='store_true'
    )
    @line_magic
    def gams_pull(self, line):
        if self.needReset:
            self.gams_reset()
        args = parse_argstring(self.gams_pull, line)
        if args.numpy:
            self.gams_pull_idx(args)
            return
        gdx = new_gdxHandle_tp()
        rc, msg = gdxCreateD(gdx, self.ws.system_directory, GMS_SSSIZE)
        if not rc:
            raise Exception(msg)
        if not gdxOpenRead(gdx, self.job.out_db.name+".gdx")[0]:
            raise Exception("Error opening GDX file " + db.name + ".gdx")
        
        specVal = doubleArray(5)
        for i in range(5):
            specVal[i] = gams.database._spec_values[i]
        if args.epsaszero:
            specVal[GMS_SVIDX_EPS] = 0.0
        if not gdxSetReadSpecialValues(gdx, specVal):
            raise Exception("Error setting special values.")
        for ident in args.symbols:
            sym = self.job.out_db[ident]
            if not (isinstance(sym, GamsParameter) or isinstance(sym, GamsSet) or isinstance(sym, GamsVariable) or isinstance(sym, GamsEquation)):
                raise Exception("Symbol type not supported by gams_pull")
            arr = self.g2np.gdxReadSymbolStr(gdx, ident)
            
            columns = []
            for col in sym.domains:
                if isinstance(col, GamsSet):
                    columns.append(col.name)
                else:
                    columns.append(col)
            if isinstance(sym, GamsParameter):
                columns.append("value")
            elif isinstance(sym, GamsVariable) or isinstance(sym, GamsEquation):
                columns.extend(["level", "marginal", "lower", "upper", "scale"])
            if isinstance(sym, GamsSet):
                self.shell.user_ns[ident] = pandas.DataFrame(arr[:,0:-1], columns = columns) #remove explanatory text
            else:
                self.shell.user_ns[ident] = pandas.DataFrame(arr, columns = columns)
            if not args.dataframe:
                if isinstance(sym, GamsParameter) and sym.dimension==0:
                    self.shell.user_ns[ident] = self.shell.user_ns[ident].values.tolist()[0]
                elif isinstance(sym, GamsSet) and sym.dimension==1:
                    self.shell.user_ns[ident] = [ x[0] for x in self.shell.user_ns[ident].values.tolist() ]
                else:
                    self.shell.user_ns[ident] = list(self.shell.user_ns[ident].itertuples(index=False, name=None))
        gdxClose(gdx)
        gdxFree(gdx)

    def raise_idx_exception(idxHandle, function):
        ret = idxErrorStr(idxHandle, idxGetLastError(idxHandle))
        raise Exception(function + "failed: " + ret[1])
        
    def write_data(self, idxHandle, keys, idx, dims, arr):
        if idx<len(dims):
            for i in range(dims[idx]):
                keys[idx] = i
                self.write_data(idxHandle, keys, idx+1, dims, arr)
        else:
            keysArr = intArray(len(dims))
            for i in range(len(dims)):
                keysArr[i] = keys[i]
            status = idxDataWrite(idxHandle, keysArr, arr.item(tuple(keys)))
            if not status:
                raise_idx_exception("idxDataWrite")
        
    def gams_push_idx(self, line):
        identList = list(filter(None, line.split(' ')))
        idxHandle = new_idxHandle_tp()
        rc =  idxCreateD(idxHandle, self.ws.system_directory, GMS_SSSIZE)
        if not rc[0]:
            raise Exception("Could not create IDX object: " + rc[1])
            
        gdxFile = os.path.join(self.ws.working_directory, self.getJobName() + "_push.gdx")
        status = idxOpenWrite(idxHandle, gdxFile, "")
        if not status:
            raise_idx_exception(idxHandle, "idxOpenWrite")
        
        status = idxSetIndexBase(idxHandle, 0)
        if not status:
            idxerror("idxSetIndexBase")
            
        for ident in identList:
            arr = self.shell.user_ns[ident]
            dims = arr.shape
            msg = ""
            dimsArr = intArray(len(dims))
            for i in range(len(dims)):
                dimsArr[i] = dims[i]
            status = idxDataWriteStart (idxHandle, ident, str(len(dims)) + "-dim Matrix", len(dims), dimsArr, GMS_SSSIZE)
            if not status[0]:
                raise_idx_exception("idxDataWriteStart")

            keys = [0]*len(dims)
            idx = 0
            
            self.write_data(idxHandle, keys, idx, dims, arr)
            status = idxDataWriteDone (idxHandle)
            if not status:
                raise_idx_exception("idxDataWriteDone")
                
        status = idxClose(idxHandle);
        if status:
            raise_idx_exception("idxClose")
        
        idxFree(idxHandle)

        code  = "$gdxin " + gdxFile + "\n"
        code += "$loadIdx "
        for ident in identList:
            code += ident + " "
        code += "\n$gdxin"
        jobName = self.getJobName() + "_push"
        self.job = self.ws.add_job_from_string(code, checkpoint=self.cp, job_name=jobName)
        self.job.run(checkpoint=self.cp)

    @line_magic
    def gams_push(self, line):
        if self.needReset:
            self.gams_reset()
        identList = list(filter(None, line.split(' ')))
        
        gamsSymbols = set()
        for ident in identList:
            if '<' in ident:
                id = ident.split('<')[-1].split('.')[0]
            elif '=' in ident:
                id = ident.split('=')[-1].split('.')[0]
            else:
                id = ident
            gamsSymbols.add(id)
            
        dbSymbols = set()
        for ident in identList:
            if '<' in ident:
                id = ident.split('<')[0]
            elif '=' in ident:
                id = ident.split('=')[0]
            else:
                id = ident
            dbSymbols.add(id)

        db = self.job.out_db
        
        nrNumpy = 0
        for s in gamsSymbols:
            pyVar = self.shell.user_ns[s]
            if isinstance(pyVar, numpy.ndarray):
                nrNumpy = nrNumpy+1
        if nrNumpy>0:
            if nrNumpy<len(gamsSymbols):
                raise Exception("Mixing numpy arrays with other data structures is not allowed.")
            else:
                self.gams_push_idx(line)
                return
        
        
        gdx = new_gdxHandle_tp()
        rc, msg = gdxCreateD(gdx, self.ws.system_directory, GMS_SSSIZE)
        if not rc:
            raise Exception(msg)
        if not gdxOpenWrite(gdx, db.name+".gdx", "")[0]:
            raise Exception("Error opening GDX file " + db.name + ".gdx")
        gdxStoreDomainSetsSet(gdx,0);
        if not gdxSetSpecialValues(gdx, gams.database._spec_values):
            raise Exception("Error setting special values.")
        #for s in gamsSymbols:
        for s, s2 in zip(dbSymbols, gamsSymbols):
            sym = db[s]
            pyVar = self.shell.user_ns[s2]

            if isinstance(pyVar, pandas.DataFrame):
                arr = pyVar.to_numpy()
            else:
                if isinstance(sym, GamsParameter) and sym.dimension==0: #scalar
                    pyVar = [[pyVar]]
                elif isinstance(sym, GamsSet) and sym.dimension==1 and len(pyVar) and isinstance(pyVar[0], str): # allow ['i1', 'i2', 'i3'] as well as [['i1'], ['i2'], ['i3']] for sets
                    pyVar = [[x] for x in pyVar]
                arr = numpy.array(pyVar, dtype=numpy.object)
            if isinstance(sym, GamsSet):
                symType = GMS_DT_SET
                subType = 0
            elif isinstance(sym, GamsParameter):
                symType = GMS_DT_PAR
                subType = 0
            elif isinstance(sym, GamsVariable):
                symType = GMS_DT_VAR
                subType = sym.vartype
            elif isinstance(sym, GamsEquation):
                symType = GMS_DT_EQU
                subType = sym.equtype
            self.g2np.gdxWriteSymbolStr(gdx, sym.name, sym.text, sym.dimension, symType, subType, arr)
        gdxClose(gdx)
        gdxFree(gdx)
            
        code =  "$gdxin %dataFromJupyter%"
        for ident in identList:
            if '<' in ident:
                id = ident.split('<')[0]
            elif '=' in ident:
                id = ident.split('=')[0]
                ident = ident.split('=')[0]
            else:
                id = ident
            code += "\n$if     defined " + id + " $loadR " + ident
            code += "\n$if not defined " + id + " $load  " + ident
        code += "\n$gdxin"
        opt = self.ws.add_options()
        opt.defines["dataFromJupyter"] = db.name
        jobName = self.getJobName() + "_push"
        self.job = self.ws.add_job_from_string(code, checkpoint=self.cp, job_name=jobName)
        
        with open(jobName + ".log", "w") as logFile:
            self.job.run(opt, checkpoint=self.cp, output=logFile)
        
    def parseTraceFile(self, trcFile):
        modelStat = ["", "Optimal Global", "OptimalLocal", "Unbounded", "InfeasibleGlobal", "InfeasibleLocal", "InfeasibleIntermed", "Feasible",
                     "Integer", "NonIntegerIntermed", "IntegerInfeasible", "LicenseError", "ErrorUnknown", "ErrorNoSolution", "NoSolutionReturned",
                     "SolvedUnique", "Solved", "SolvedSingular", "UnboundedNoSolution", "InfeasibleNoSolution"]
        solveStat = ["", "Normal", "Iteration", "Resource", "Solver", "EvalError", "Capability", "License", "User", "SetupErr", "SolverErr", "InternalErr", "Skipped", "SystemErr"]
        
        with open(trcFile, 'r') as f:
            lines = f.readlines()
            if len(lines) < 6: # no solve in GAMS code
                return None
            header = (lines[2] + lines[3]).replace('*', '').replace('\n', '').replace(' ', '').split(',')
            usedColumns = [ "ModelType" , "SolverName", "NumberOfEquations", "NumberOfVariables", "ModelStatus" , "SolverStatus" , "ObjectiveValue", "SolverTime" ]
            altColNames = [ "Model Type", "Solver"    , "#equ"             , "#var"             , "Model Status", "Solver Status", "Objective"     , "Solver Time"]
            data = []
            for l in lines[5:]:
                values = l.split(',')
                displayValues = []
                for idx in range(len(header)):
                    if header[idx] in usedColumns:
                        if header[idx] == "ModelStatus":
                            displayValues.append(modelStat[int(values[idx])] + " (" + values[idx] + ")")
                        elif header[idx] == "SolverStatus":
                            displayValues.append(solveStat[int(values[idx])] + " (" + values[idx] + ")")
                        elif header[idx] == "ObjectiveValue":
                            if values[idx] != 'NA':
                                displayValues.append(round(float(values[idx]), 4))
                            else:
                                displayValues.append('NA')
                        else:
                            displayValues.append(values[idx])
                        
                data.append(displayValues)

            df = pandas.DataFrame(data, columns=altColNames)
            df = df[["Solver Status", "Model Status", "Objective", "#equ" , "#var", "Model Type", "Solver", "Solver Time" ]]
            return df
    
    @magic_arguments()
    @argument(
        '-o', '--output', action='append',
        help=("One or multiple GAMS symbol identifiers separated by comma that are supposed to be pulled from GAMS after running the code")
    )
    @argument(
        '-i', '--input', action='append',
        help=("One or multiple GAMS symbol identifiers separated by comma that are supposed to be pushed to GAMS before running the code")
    )
    @argument(
        'code',
        nargs='*'
        )
    @argument(
        '-r', '--reset', action='store_true'
        )
    @line_cell_magic
    def gams(self, line, cell=None):
        args = parse_argstring(self.gams, line)
        if args.reset or self.needReset:
            self.gams_reset()

        if args.input:
            inArgs =  ",".join(args.input).split(',')
            inArgs = " ".join(inArgs)
            self.gams_push(inArgs)

        code = []
        if args.code:
            code.append(" ".join(args.code))
        if cell:
            code.append(cell)
        code = "\n".join(code)
        
        solveSummary = None
        if code:
            code = "$offeolcom\n$eolcom #\n" + code
            jobName = self.getJobName()
            self.job = self.ws.add_job_from_string(code, checkpoint=self.cp, job_name=jobName)
            opt = self.ws.add_options()
            trcFileName = jobName + ".trc"
            trcFilePath = os.path.join(self.ws.working_directory, trcFileName)
            if os.path.isfile(trcFilePath):
                os.remove(trcFilePath)
            opt.trace = trcFileName
            opt.traceopt = 3
            with open(jobName + ".log", "w") as logFile:
                self.job.run(opt, checkpoint=self.cp, output=logFile)
            solveSummary = self.parseTraceFile(trcFilePath)
            
        if args.output:
            outArgs = ",".join(args.output).split(',')
            outArgs = " ".join(outArgs)
            self.gams_pull(outArgs)
            
        return solveSummary
        
